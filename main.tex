% ****** Start of file aipsamp.tex ******
%
%   This file is part of the AIP files in the AIP distribution for REVTeX 4.
%   Version 4.1 of REVTeX, October 2009
%
%   Copyright (c) 2009 American Institute of Physics.
%
%   See the AIP README file for restrictions and more information.
%
% TeX'ing this file requires that you have AMS-LaTeX 2.0 installed
% as well as the rest of the prerequisites for REVTeX 4.1
%
% It also requires running BibTeX. The commands are as follows:
%
%  1)  latex  aipsamp
%  2)  bibtex aipsamp
%  3)  latex  aipsamp
%  4)  latex  aipsamp
%
% Use this file as a source of example code for your aip document.
% Use the file aiptemplate.tex as a template for your document.
\documentclass[%
 aip,
 jmp,%
 amsmath,amssymb,
%preprint,%
 reprint,%
%author-year,%
%author-numerical,%
]{revtex4-1}

\usepackage{graphicx}% Include figure files
\usepackage{dcolumn}% Align table columns on decimal point
\usepackage{bm}% bold math
\usepackage{mathtools}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{azure}{rgb}{0.0, 0.5, 1.0}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{azure},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=none,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}
%\usepackage[mathlines]{lineno}% Enable numbering of text and display math
%\linenumbers\relax % Commence numbering lines

\newcommand{\rom}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

\begin{document}

%\preprint{AIP/123-QED}

\title[COMP20007 Assignment 1]{Isitha Subasinghe}% Force line breaks with \\

\author{911584}

\date{\today}% It is always \today, today,
             %  but any date may be explicitly specified

\maketitle

\begin{center}
    \vspace{2.5mm}
    First we will define some variables. \\
    \vspace{1.25mm}
    $\boldsymbol{d \ \coloneqq \ number \ of \ documents} $ \\
    $\boldsymbol{q \ \coloneqq \ number \ of \ queries} $ \\
    $\boldsymbol{r \ \coloneqq \ number \ of \ results} $ \\
    \vspace{2.5mm}
\end{center}

\section{\label{sec:level1}Analysis of array based 
    'top-k' algorithm.}

\begin{center}
    Worst Case scenario for the array based 'top-k' algorithm. \\
    
    \begin{tabular}{|c|} 
        \hline
            Worst Case \\ [0.5ex] 
            \hline
            $\mathcal{O}(dq + d\log{}r)$ \\ 
            \hline
    \end{tabular}
    
    \vspace{2.5mm}
    This section of this time complexity analysis will attempt to show that the
    worst case scenario for the array based 'top-k' algorithm is the one shown above.
    Some asymptotically irrelevant segments of code will be avoided in this .
\end{center}


\subsection{\label{sec:level2} Task 1: $\mathcal{O}(dq)$ term)}

\begin{lstlisting}[style=CStyle]
for(int i=0; i < index->num_terms; i++) {
    List *list = index->doclists[i]; 
    Node *node = list->head;
    while(node != NULL) {
    	Document *doc = (Document *)node->data;
    	scores[doc->id] += doc->score;
    	node = node->next;
    }
}
\end{lstlisting}

\begin{center}
    There is essentially two loops in this segment of code.
    Since the two loops are dependent on two variables, we
    can state that the asymptotic run time of this section is
    of $\mathcal{O}(dq)$. The $\mathcal{O}(q)$ term is simply
    from the for loop iterating through all the terms/queries. 
    The $\mathcal{O}(d)$ term is from the while loop, which 
    contains the document lists. Since each for loop contains
    a while loop, the run time for this segment is $\mathcal{O}(dq)$.
\end{center}


\subsection{\label{sec:level3}Task 1: $\mathcal{O}(d\log{}r)$ term}

\begin{lstlisting}[style=CStyle]
for(int i=0; i < n_documents; i++) {
		if(topk->len < n_results) {
			heap_insert(topk, scores[i], i);
		}else {
			float min = heap_peak_key(topk);
			if(scores[i] > min) {
				heap_remove_min(topk);
				heap_insert(topk, scores[i], i);
			}
		}
}
\end{lstlisting}

\begin{center}
    The run time of this segment is $\mathcal{O}(d\log{}r)$, this is
    from the iteration and insertion of values. from the score array.
    The $\mathcal{O}(d)$ term is from the for loop which iterates 
    through the number of documents. The $\mathcal{O}(\log{}r)$ 
    term is from the worst case scenario for a heap insertion. 
    This worst case for a heap insertion means that the siftup
    procedure has to be applied to the length of the tree which is 
    $\mathcal{O}(\log{}r)$.
\end{center}

\subsection{\label{sec:level4}Task 1: Conclusion}

\begin{center}
    Subsections A and B make clear that the run time
    is of $\mathcal{O}(dq + d\log{}r)$, where the $\mathcal{O}(dq)$
    term is from the summation of document scores and the 
    $\mathcal{O}(d\log{}r)$ is from the heap insertion process.
\end{center}


\section{\label{sec1:level1} Analysis of multi way merge based 'top-k' algorithm}

\begin{center}
    Worst Case scenario for the multi way based 'top-k' algorithm. \\
    
    \begin{tabular}{|c|} 
        \hline
            Worst Case \\ [0.5ex] 
            \hline
            $\mathcal{O}(dq\log{}q + dq\log{}r)$ \\ 
            \hline
    \end{tabular}
    
    \vspace{2.5mm}
    This section of this time complexity analysis will attempt to show that the
    worst case scenario for the multi way merge based 'top-k' algorithm is the one shown above. \\
    \vspace{3mm}
    Code segments as shown in the analysis of task 1 will be avoided since the code 
for task 2 is much more verbose. Instead the algorithmic process shall be discussed.
\end{center}

\subsection{\label{sec1:level2}Task 2: $\mathcal{O}(dq\log{}q )$ term}

\begin{center}
The $\mathcal{O}(dq\log{}q )$ term is derived from a heap insert performed inside a for loop which itself is inside a while loop. The time for a heap insert is $\mathcal{O}(\log{}q )$, the inner most loop iterates over the queries and hence is $\mathcal{O}(q)$, the while loop has an exit condition when the document lists are empty, therefore it is $\mathcal{O}(d)$.
\end{center}

\subsection{\label{sec1:level3}Task 2: $\mathcal{O}(dq\log{}r )$ term}

\begin{center}
The $\mathcal{O}(dq\log{}r )$ term arises from the worst case scenario where all the document id's for all the queries are unique, in this case all this data must be inserted into the heap. The terms are derived from the same code segments discussed above, however instead of inserting into a index heap, the values are inserted into the results heap.  
\end{center}

\subsection{\label{sec1:level4} Conclusion}

\begin{center}
The subsections A and B of section \rom{2} make clear that 
$mathcal{O}(dq\log{}q)$ arises from the insertion to the index heap and
that the $mathcal{O}(dq\log{}r)$ arises from the insertion to the results heap. 
Hence providing the multi way algorithm with a run time of
$\mathcal{O}(dq\log{}q + dq\log{}r)$.
\end{center}

\section{\label{sec2:level1} Use cases of different algorithms}

\subsection{\label{sec2:level2} Memory constraints}

\begin{center}
The algorithm recommended for a memory constrained system is the multi way 
merge based algorithm. This algorithm is preferred over the array based algorithm
since it is memory heavy. The multi way merge algorithm uses only two heaps and a array of size q (not including printing based arrays) while offering
a reasonable average case time complexity, while the array based algorithm uses 
an array which is the size of the number of documents.
\end{center}

\subsection{\label{sec2:level3} Speed requirements}
Should the system require the best possible worst case time complexity, the 
array based algorithm is superior to the multi way merge based algorithm. 
However this is at the cost of excessive memory usage when compared to multi way
merge based algorithm.

\subsection{\label{sec2:level4} General case}
For general cases, the best suited algorithm would be the multi way algorithm, since
it offers a reasonable average case, while being very efficient on memory.
 

\end{document}
%
% ****** End of file aipsamp.tex ******
